object session {

  /********** #1 **********/
  // Generic compose combinator
  // (the input of f should be the same as the output of g)
	def compose[A, B](f: A => B, g: B => A): B => B = {
		def r(x: B):
			B = f(g(x));
   	r _
	}                                         //> compose: [A, B](f: A => B, g: B => A)B => B
	
	// --- Tester functions --- //
	def triple(x: Int): Int = 3 * x           //> triple: (x: Int)Int
	def square(x: Int) = x * x                //> square: (x: Int)Int
	val squareTriple = compose(square _, triple _)
                                                  //> squareTriple  : Int => Int = session$$$Lambda$10/434091818@2acf57e3
	// Test without composition function
	square(triple(2))                         //> res0: Int = 36
	square(triple(5))                         //> res1: Int = 225
	
	// Testing the composition function
	squareTriple(2)                           //> res2: Int = 36
	squareTriple(5)                           //> res3: Int = 225
	
  
  /********** #2 **********/
  
  def selfIter[T](f: T=>T, n: Int): T => T = {
  //f composed with itself n times.
  		if (n == 0) f
  		else	 {
  			def test = selfIter(f, n - 1)
  			compose(f, test)
  		}
  }                                               //> selfIter: [T](f: T => T, n: Int)T => T
  
  // --- Tester functions --- //
  def inc(x: Double) = x + 1                      //> inc: (x: Double)Double
	def double(x: Double) = 2 * x             //> double: (x: Double)Double
	
	// Testing the selfIter function
	def doubleIncSelfIter(n: Int, m: Int) = {
		def innerTest = selfIter(compose(double, inc), m)
		innerTest(n)
	}                                         //> test: (n: Int, m: Int)Double
	
	doubleIncSelfIter(3, 0)		// double(inc(3)) //> res4: Double = 8.0
	
	/*
def selfIter3[T](f: T=>T, n: Int): T => T = Function.chain(List.fill(n)(f))
println(selfIter3[Double](compose(double, inc), 2)(2.0))
*/

  /********** #3 **********/
  
  
  /********** #4 **********/
  
  
  /********** #5 **********/
  
  
}