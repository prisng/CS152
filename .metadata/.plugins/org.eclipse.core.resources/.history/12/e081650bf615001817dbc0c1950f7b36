object recursionSession {

  def inc(n: Int) = n + 1
	def dec(n: Int) = n - 1
	def isZero(n: Int) = n == 0
  
  /********** #1 **********/
  // Recursive
  def add(n: Int, m: Int): Int = {
  		if (isZero(m)) n
  		else add(inc(n), dec(m))
  }
  
  val t0 = System.nanoTime()
  add(3, 5)
  add(5, 5)
  add(100, 99)
  val t1 = System.nanoTime()
  val recurDiff = t1 - t0
  println("Time elapsed: " + recurDiff + "ns")
  
  
  /********** #2 **********/
  // Recursive
  def mul(n: Int, m: Int): Int = {
    	var result = n
  		if (isZero(n) || isZero(m)) result = 0
  		if (m > 1) {
  			result = add(n, mul(n, dec(m))) // result = n * (m - 1) + n
  		}
  		result
  }
  
  mul(0, 999)
  mul(3, 5)
  mul(5, 5)
  mul(12, 12)
  mul(30, 3)
  
  
  /********** #3 **********/
  // Recursive
  def exp2(m: Int): Int = {
  		if (isZero(m)) 1
  		else mul(2, exp2(dec(m)))
  }
  
  exp2(0)
  exp2(1)
  exp2(2)
  exp2(3)
  exp2(4)
  exp2(5)
  exp2(10)
 	// stack overflow once m >= 15 is called


  /********** #4 **********/
  // Recursive
  def hyperExp(n: Int): Int = {
  		if (isZero(n)) 1
  		else exp2(hyperExp(dec(n)))
  }
	
	hyperExp(0)
	hyperExp(1)
	hyperExp(2)
	hyperExp(3)
	// Stack overflow once n >= 4 is called


  /********** #5 **********/
	/** Tail-recursive implementations of #1-4 **/
	
	// Tail-recursive implementation of #1
  def addTR(n: Int, m: Int) = {
  		def addHelper(result: Int, count: Int): Int =
  		  	if (isZero(count)) result
  			else addHelper(inc(result), dec(count))
  		addHelper(n, m)
  }
  
  val t2 = System.nanoTime()
  addTR(1, 2)
  addTR(3, 5)
  addTR(5, 5)
 	addTR(100, 99)
  val t3 = System.nanoTime()
  val trDiff = t3 - t2
  println("Time elapsed: " + (t3 - t2) + "ns")
  
  if (trDiff < recurDiff) println("Tail-recurisve is faster by " + (recurDiff - trDiff) + "ns")

	// Tail-recursive implementation of 2
	
	def mulTR(n: Int, m: Int) = {
		if (isZero(n) || isZero(m)) 0
		def mulHelper(count: Int, result: Int): Int = {
			if (count >= m) result else mulHelper(inc(count), add(result, n))
		}
		mulHelper(1, n)
	}
	
	mulTR(3, 5)
	mulTR(4, 5)
	mulTR(10, 10)
	mulTR(0, 150)
	mulTR(12, 12)
  
  // Tail-recursive implementation of 3
	def exp2TR(m: Int) = {
 		def helper (count: Int, result: Int): Int =
 			if (m < count) result else helper(count + 1, 2 * result)
 		helper(1, 1)
  }
  
  exp2TR(0)
  exp2TR(1)
  exp2TR(4)
  exp2TR(5)
  exp2TR(10)
  exp2TR(20)
  
  // Tail-recursive implementation of 4
	def hyperExpTR(n: Int) = {
  if (n == 0) 1
    def hyperExpHelper(count: Int, result: Int): Int =
      if (n < count) result else hyperExpHelper(inc(count), hyperExp(dec(n)))
    hyperExpHelper(1, 1)
	}

	hyperExpTR(0)
	hyperExpTR(1)
	hyperExpTR(2)
	hyperExpTR(3)
	hyperExpTR(4)
	
	/*
	  def hyperExp(n: Int): Int = {
  		if (isZero(n)) 1
  		else exp2(hyperExp(dec(n)))
  }
	*/
	
	/********** #9 **********/
	// Recursive
	def fib(n: Int): Int = {
		if (isZero(n)) 0
		else if (n == 1) 1
		else fib(n - 1) + fib(n - 2)
	}
	
	fib(0)
	fib(1)
	fib(2)
	fib(3)
	fib(5)
	fib(6)
	fib(10)
	fib(15)
	
	
	// Tail-recursive
	def fibTR(n: Int) = {
		def fibHelper(count: Int, result: Int, prevResult: Int): Int = count match {
			case 0 => 0
			case 1 => result
			case _ => fibHelper(count - 1, result + prevResult, result)
		}
		fibHelper(n, 1, 0)
	}
	
	fibTR(0)
	fibTR(1)
	fibTR(2)
	fibTR(3)
	fibTR(6)
	fibTR(10)
	fibTR(15)
	fibTR(20)
	
	
	/********** #10 **********/
	def choose(n: Int, m: Int): Int =
		m match {
			case m if m == 0 || m == n => 1
			case m if m > n => 0
			case _ => choose(dec(n), m) + choose(dec(n), dec(m))
		}
	
	choose(4, 5)
	choose(8, 4)
	choose(5, 3)
	choose(100, 1)
	choose(100, 0)
	choose(100, 100)
}